<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulazione Spaziale</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Arial', sans-serif; background-color: #000; }
        canvas { display: block; }
        .clock-container {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: rgba(0, 0, 0, 0.4);
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
            border: 1px solid #00ffff;
            padding: 0.5rem;
            font-size: 0.75rem;
            color: #00ffff;
            font-family: 'Courier New', Courier, monospace;
            text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff;
            border-radius: 8px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        @media (max-width: 600px) {
            .clock-container {
                top: 0.5rem;
                left: 0.5rem;
                font-size: 0.6rem;
            }
        }
    </style>
</head>
<body>
    <div class="clock-container">
        <p id="time-text"></p>
    </div>
    <script src="/local/space/three.min.js"></script>
    <script src="/local/space/OrbitControls.js"></script>
    <script>
        const SimplexNoise = (function() {
            var random = Math.random;
            var perm = new Uint8Array(512);
            var p = new Uint8Array(256);

            for (var i = 0; i < 256; i++) {
                p[i] = i;
            }

            for (var i = 0; i < 255; i++) {
                var r = i + Math.floor(random() * (256 - i));
                var temp = p[i];
                p[i] = p[r];
                p[r] = temp;
            }

            for (var i = 0; i < 512; i++) {
                perm[i] = p[i & 255];
            }

            function grad3d(i, x, y, z) {
                var h = i & 15;
                var u = h < 8 ? x : y;
                var v = h < 4 ? y : (h == 12 || h == 14 ? x : z);
                return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
            }

            return {
                noise3d: function(xin, yin, zin) {
                    var n0, n1, n2, n3;
                    var s = (xin + yin + zin) / 3;
                    var i = Math.floor(xin + s);
                    var j = Math.floor(yin + s);
                    var k = Math.floor(zin + s);

                    var t = (i + j + k) / 3;
                    var x0 = xin - (i - t);
                    var y0 = yin - (j - t);
                    var z0 = zin - (k - t);

                    var i1, j1, k1;
                    var i2, j2, k2;

                    if (x0 >= y0) {
                        if (y0 < z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; } else { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; }
                    } else {
                        if (y0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; } else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
                    }

                    if (x0 >= z0) {
                        if (y0 < z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; } else { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; }
                    } else {
                        if (y0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; } else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
                    }

                    var x1 = x0 - i1 + 1 / 3; var y1 = y0 - j1 + 1 / 3; var z1 = z0 - k1 + 1 / 3;
                    var x2 = x0 - i2 + 2 / 3; var y2 = y0 - j2 + 2 / 3; var z2 = z0 - k2 + 2 / 3;
                    var x3 = x0 - 1 + 1 / 3; var y3 = y0 - 1 + 1 / 3; var z3 = z0 - 1 + 1 / 3;

                    var ii = i & 255; var jj = j & 255; var kk = k & 255;
                    var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
                    if (t0 < 0) n0 = 0;
                    else { t0 *= t0; n0 = t0 * t0 * grad3d(perm[ii + perm[jj + perm[kk]]], x0, y0, z0); }

                    var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
                    if (t1 < 0) n1 = 0;
                    else { t1 *= t1; n1 = t1 * t1 * grad3d(perm[ii + i1 + perm[jj + j1 + perm[kk + k1]]], x1, y1, z1); }

                    var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
                    if (t2 < 0) n2 = 0;
                    else { t2 *= t2; n2 = t2 * t2 * grad3d(perm[ii + i2 + perm[jj + j2 + perm[kk + k2]]], x2, y2, z2); }

                    var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
                    if (t3 < 0) n3 = 0;
                    else { t3 *= t3; n3 = t3 * t3 * grad3d(perm[ii + 1 + perm[jj + 1 + perm[kk + 1]]], x3, y3, z3); }
                    return 32 * (n0 + n1 + n2 + n3);
                }
            };
        })();

        let scene, camera, renderer, controls;
        let earth, moon, stars, satellite;
        let sunLight;
        let meteorites = [];
        const MAX_METEORITES = 20;
        const EARTH_RADIUS = 2;
        const ATMOSPHERE_HEIGHT_KM = 100;
        const ATMOSPHERE_RADIUS = EARTH_RADIUS + (ATMOSPHERE_HEIGHT_KM / 6371) * EARTH_RADIUS;

        let specialMeteorite = null;
        const SPECIAL_METEORITE_SPAWN_DISTANCE = 25;

        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        // Velocità realistiche
        const REALISTIC_EARTH_ROTATION_SPEED = (2 * Math.PI) / (23.9344696 * 60 * 60); // Radianti per secondo (giorno siderale)
        const REALISTIC_MOON_SPEED = 0.0000000026617; // Radianti per millisecondo (rotazione e orbita)

        // PARAMETRI PER L'INCLINAZIONE E L'ORBITA ELLITTICA
        const EARTH_AXIAL_TILT = THREE.MathUtils.degToRad(23.5);
        const ORBITAL_ECCENTRICITY = 0.0167; // Eccentricità dell'orbita terrestre
        const SUN_DISTANCE = 10;
        const ORBIT_SEMI_MAJOR_AXIS = SUN_DISTANCE;
        const ORBIT_SEMI_MINOR_AXIS = ORBIT_SEMI_MAJOR_AXIS * Math.sqrt(1 - ORBITAL_ECCENTRICITY**2);

        let earthOrbitAngle = 0;
        let initialEarthRotation = 0;
        let userLongitude = 0;

        const MOON_ORBIT_INCLINATION = THREE.MathUtils.degToRad(5.14);
        const MOON_ORBIT_RADIUS = 5;

        const SATELLITE_ORBIT_RADIUS = 3.5;
        const SATELLITE_ORBIT_SPEED = (2 * Math.PI) / 60000;
        const SATELLITE_INCLINATION = THREE.MathUtils.degToRad(30);

        let moonOrbitAngle = 0;
        let satelliteOrbitAngle = 0;

        // Il gruppo che contiene la Terra e l'atmosfera
        let earthGroup;
        let sunGroup;

        let meteoriteTrailParticles = [];
        let cameraMode = 'orbit';

        let satelliteState = 'orbiting';
        const SATELLITE_LAUNCH_SPEED = 0.002;
        let satelliteLaunchVelocity;

        // Gestione del touch per mobile
        let touchTimer;
        const LONG_PRESS_THRESHOLD = 500;
        let lastTap = 0;
        const DOUBLE_TAP_THRESHOLD = 300; // Tempo in millisecondi

        function calculateInitialMoonPhase() {
            const now = new Date();
            const year = now.getFullYear();
            const month = now.getMonth() + 1;
            const day = now.getDate();
            const hour = now.getHours();
            const minute = now.getMinutes();
            const second = now.getSeconds();
