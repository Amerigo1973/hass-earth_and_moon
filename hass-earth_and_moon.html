<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulazione Spaziale</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Arial', sans-serif; background-color: #000; }
        canvas { display: block; }
        .clock-container {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: rgba(0, 0, 0, 0.4);
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
            border: 1px solid #00ffff;
            padding: 0.5rem;
            font-size: 0.75rem;
            color: #00ffff;
            font-family: 'Courier New', Courier, monospace;
            text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff;
            border-radius: 8px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        @media (max-width: 600px) {
            .clock-container {
                top: 0.5rem;
                left: 0.5rem;
                font-size: 0.6rem;
            }
        }
    </style>
</head>
<body>
    <div class="clock-container">
        <p id="time-text"></p>
    </div>
    <script src="/local/space/three.min.js"></script>
    <script src="/local/space/OrbitControls.js"></script>
    <script>
        const SimplexNoise = (function() {
            var random = Math.random;
            var perm = new Uint8Array(512);
            var p = new Uint8Array(256);

            for (var i = 0; i < 256; i++) {
                p[i] = i;
            }

            for (var i = 0; i < 255; i++) {
                var r = i + Math.floor(random() * (256 - i));
                var temp = p[i];
                p[i] = p[r];
                p[r] = temp;
            }

            for (var i = 0; i < 512; i++) {
                perm[i] = p[i & 255];
            }

            function grad3d(i, x, y, z) {
                var h = i & 15;
                var u = h < 8 ? x : y;
                var v = h < 4 ? y : (h == 12 || h == 14 ? x : z);
                return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
            }

            return {
                noise3d: function(xin, yin, zin) {
                    var n0, n1, n2, n3;
                    var s = (xin + yin + zin) / 3;
                    var i = Math.floor(xin + s);
                    var j = Math.floor(yin + s);
                    var k = Math.floor(zin + s);

                    var t = (i + j + k) / 3;
                    var x0 = xin - (i - t);
                    var y0 = yin - (j - t);
                    var z0 = zin - (k - t);

                    var i1, j1, k1;
                    var i2, j2, k2;

                    if (x0 >= y0) {
                        if (y0 < z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; } else { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; }
                    } else {
                        if (y0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; } else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
                    }

                    if (x0 >= z0) {
                        if (y0 < z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; } else { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; }
                    } else {
                        if (y0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; } else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
                    }
                    
                    var x1 = x0 - i1 + 1 / 3; var y1 = y0 - j1 + 1 / 3; var z1 = z0 - k1 + 1 / 3;
                    var x2 = x0 - i2 + 2 / 3; var y2 = y0 - j2 + 2 / 3; var z2 = z0 - k2 + 2 / 3;
                    var x3 = x0 - 1 + 1 / 3; var y3 = y0 - 1 + 1 / 3; var z3 = z0 - 1 + 1 / 3;

                    var ii = i & 255; var jj = j & 255; var kk = k & 255;
                    var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
                    if (t0 < 0) n0 = 0;
                    else { t0 *= t0; n0 = t0 * t0 * grad3d(perm[ii + perm[jj + perm[kk]]], x0, y0, z0); }

                    var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
                    if (t1 < 0) n1 = 0;
                    else { t1 *= t1; n1 = t1 * t1 * grad3d(perm[ii + i1 + perm[jj + j1 + perm[kk + k1]]], x1, y1, z1); }

                    var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
                    if (t2 < 0) n2 = 0;
                    else { t2 *= t2; n2 = t2 * t2 * grad3d(perm[ii + i2 + perm[jj + j2 + perm[kk + k2]]], x2, y2, z2); }

                    var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
                    if (t3 < 0) n3 = 0;
                    else { t3 *= t3; n3 = t3 * t3 * grad3d(perm[ii + 1 + perm[jj + 1 + perm[kk + 1]]], x3, y3, z3); }
                    return 32 * (n0 + n1 + n2 + n3);
                }
            };
        })();

        let scene, camera, renderer, controls;
        let earth, moon, stars, satellite;
        let sunLight;
        let meteorites = [];
        const MAX_METEORITES = 20;
        const EARTH_RADIUS = 2; 
        const ATMOSPHERE_HEIGHT_KM = 100;
        const ATMOSPHERE_RADIUS = EARTH_RADIUS + (ATMOSPHERE_HEIGHT_KM / 6371) * EARTH_RADIUS; 

        let specialMeteorite = null;
        const SPECIAL_METEORITE_SPAWN_DISTANCE = 25;
        
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        // Velocità realistiche
        const REALISTIC_EARTH_ROTATION_SPEED = (2 * Math.PI) / (23.9344696 * 60 * 60); // Radianti per secondo (giorno siderale)
        const REALISTIC_MOON_SPEED = 0.0000000026617; // Radianti per millisecondo (rotazione e orbita)
        
        // PARAMETRI PER L'INCLINAZIONE E L'ORBITA ELLITTICA
        const EARTH_AXIAL_TILT = THREE.MathUtils.degToRad(23.5);
        const ORBITAL_ECCENTRICITY = 0.0167; // Eccentricità dell'orbita terrestre
        const SUN_DISTANCE = 10;
        const ORBIT_SEMI_MAJOR_AXIS = SUN_DISTANCE;
        const ORBIT_SEMI_MINOR_AXIS = ORBIT_SEMI_MAJOR_AXIS * Math.sqrt(1 - ORBITAL_ECCENTRICITY**2);

        let earthOrbitAngle = 0;
        let initialEarthRotation = 0;
        let userLongitude = 0; 

        const MOON_ORBIT_INCLINATION = THREE.MathUtils.degToRad(5.14);
        const MOON_ORBIT_RADIUS = 5;

        const SATELLITE_ORBIT_RADIUS = 3.5;
        const SATELLITE_ORBIT_SPEED = (2 * Math.PI) / 60000;
        const SATELLITE_INCLINATION = THREE.MathUtils.degToRad(30);

        let moonOrbitAngle = 0;
        let satelliteOrbitAngle = 0;
        
        // Il gruppo che contiene la Terra e l'atmosfera
        let earthGroup;
        let sunGroup;

        let meteoriteTrailParticles = [];
        let cameraMode = 'orbit'; 
        
        let satelliteState = 'orbiting'; 
        const SATELLITE_LAUNCH_SPEED = 0.002;
        let satelliteLaunchVelocity;
        
        // Gestione del touch per mobile
        let touchTimer;
        const LONG_PRESS_THRESHOLD = 500; 

        function calculateInitialMoonPhase() {
            const now = new Date();
            const year = now.getFullYear();
            const month = now.getMonth() + 1;
            const day = now.getDate();
            const hour = now.getHours();
            const minute = now.getMinutes();
            const second = now.getSeconds();
            const JD = 367 * year - Math.floor(7 * (year + Math.floor((month + 9) / 12)) / 4) + Math.floor(275 * month / 9) + day + 1721013.5 + (hour + minute / 60 + second / 3600) / 24;
            const JD_NEW_MOON_REF = 2451550.1;
            const MOON_SYNODIC_PERIOD = 29.530588853;
            const elapsedCycles = (JD - JD_NEW_MOON_REF) / MOON_SYNODIC_PERIOD;
            const phaseFraction = elapsedCycles - Math.floor(elapsedCycles);
            return phaseFraction * 2 * Math.PI;
        }

        function calculateEarthRotation(longitude) {
            const now = new Date();
            const JD = now.getTime() / 86400000 + 2440587.5; 
            const T = (JD - 2451545.0) / 36525.0; 
            const GMST = 280.46061837 + 360.98564736629 * (JD - 2451545.0) + T * T * (0.000387933 - T / 38710000.0);
            const GMST_Deg = GMST % 360;
            const LST_Deg = GMST_Deg + longitude;
            return THREE.MathUtils.degToRad(LST_Deg);
        }

        function calculateInitialEarthOrbitAngle() {
            const now = new Date();
            const dayOfYear = (Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()) - Date.UTC(now.getFullYear(), 0, 0)) / 24 / 60 / 60 / 1000;
            const totalDaysInYear = now.getFullYear() % 4 === 0 ? 366 : 365;
            const fractionOfYear = dayOfYear / totalDaysInYear;
            return fractionOfYear * 2 * Math.PI;
        }

        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, canvas.width / 2
            );
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,1)');
            gradient.addColorStop(1, 'rgba(0,0,0,1)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);
            return new THREE.CanvasTexture(canvas);
        }

        function updateClock() {
            const now = new Date();
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit' };
            const formattedTime = now.toLocaleString(undefined, options);
            document.getElementById('time-text').textContent = formattedTime;
        }

        function generateRoughMeteoriteGeometry(radius, detail, roughness = 0.2) {
            const geometry = new THREE.IcosahedronGeometry(radius, detail);
            const positionAttribute = geometry.getAttribute('position');
            const tempVector = new THREE.Vector3();
            for (let i = 0; i < positionAttribute.count; i++) {
                tempVector.fromBufferAttribute(positionAttribute, i);
                const noise = SimplexNoise.noise3d(tempVector.x * 5, tempVector.y * 5, tempVector.z * 5); 
                const factor = 1 + noise * roughness; 
                tempVector.normalize().multiplyScalar(radius * factor);
                positionAttribute.setXYZ(i, tempVector.x, tempVector.y, tempVector.z);
            }
            geometry.computeVertexNormals();
            return geometry;
        }

        function createMeteorite() {
            const radius = THREE.MathUtils.randFloat(0.01, 0.05);
            const detail = 0;
            const meteoriteGeometry = new THREE.IcosahedronGeometry(radius, detail);
            const meteoriteMaterial = new THREE.MeshStandardMaterial({
                color: new THREE.Color(Math.random() * 0x333333 + 0x666666),
                roughness: 0.8,
                metalness: 0.1
            });
            const meteorite = new THREE.Mesh(meteoriteGeometry, meteoriteMaterial);

            const distance = THREE.MathUtils.randFloat(20, 30);
            const angle = Math.random() * Math.PI * 2;
            const yOffset = THREE.MathUtils.randFloat(-10, 10);
            meteorite.position.set(
                Math.cos(angle) * distance,
                yOffset,
                Math.sin(angle) * distance
            );

            meteorite.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.1,
                (Math.random() - 0.5) * 0.1,
                (Math.random() - 0.5) * 0.1
            ).normalize().multiplyScalar(THREE.MathUtils.randFloat(0.05, 0.15));

            meteorite.velocity.add(new THREE.Vector3().subVectors(new THREE.Vector3(0,0,0), meteorite.position).normalize().multiplyScalar(0.01));

            meteorite.isBurning = false;
            meteorite.burnStartTime = 0;
            meteorite.meteoriteBurnDuration = THREE.MathUtils.randFloat(2, 4);
            meteorite.initialScale = radius;
            meteorite.lastParticleTime = 0;
            
            scene.add(meteorite);
            meteorites.push(meteorite);
        }

        function generateMeteoriteTexture(width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const context = canvas.getContext('2d');
            const imageData = context.createImageData(width, height);
            const data = imageData.data;
            
            const baseScale = 0.05; 
            const detailScale1 = 0.2; 
            const detailScale2 = 0.5; 

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let noise1 = SimplexNoise.noise3d(x * baseScale, y * baseScale, 0);
                    let noise2 = SimplexNoise.noise3d(x * detailScale1, y * detailScale1, 10);
                    let noise3 = SimplexNoise.noise3d(x * detailScale2, y * detailScale2, 20);

                    let combinedNoise = (noise1 * 0.6 + noise2 * 0.2 + noise3 * 0.1);
                    
                    let normalizedNoise = (combinedNoise + 1) / 2;
                    let r = Math.floor(normalizedNoise * 80 + 20); 
                    let g = Math.floor(normalizedNoise * 70 + 20); 
                    let b = Math.floor(normalizedNoise * 60 + 20); 

                    const index = (y * width + x) * 4;
                    data[index] = r;      
                    data[index + 1] = g;  
                    data[index + 2] = b;  
                    data[index + 3] = 255;  
                }
            }
            
            context.putImageData(imageData, 0, 0);
            return canvas;
        }

        function createSpecialMeteorite(targetObject) {
            const radius = THREE.MathUtils.randFloat(0.1, 0.4); 
            const meteoriteGeometry = generateRoughMeteoriteGeometry(radius, 2, 0.3); 
            const meteoriteTexture = new THREE.CanvasTexture(generateMeteoriteTexture(1024, 1024)); 
            const meteoriteMaterial = new THREE.MeshStandardMaterial({
                map: meteoriteTexture,
                color: 0xffffff,
                emissive: 0x000000,
                emissiveIntensity: 0.0,
                roughness: 0.9,
                metalness: 0.1,
                transparent: true,
                opacity: 1.0
            });
            
            specialMeteorite = new THREE.Mesh(meteoriteGeometry, meteoriteMaterial);

            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            
            const startPosition = camera.position.clone().add(cameraDirection.negate().multiplyScalar(SPECIAL_METEORITE_SPAWN_DISTANCE));
            specialMeteorite.position.copy(startPosition);
            
            let targetPosition;
            if (targetObject === 'moon') {
                targetPosition = moon.position.clone();
                specialMeteorite.targetIsMoon = true;
            } else {
                targetPosition = new THREE.Vector3(0, 0, 0);
                specialMeteorite.targetIsMoon = false;
            }

            specialMeteorite.velocity = new THREE.Vector3().subVectors(targetPosition, specialMeteorite.position).normalize();
            specialMeteorite.speed = THREE.MathUtils.randFloat(0.3, 0.5); 
            
            specialMeteorite.isSpecial = true;
            specialMeteorite.isBurning = false; 
            specialMeteorite.isOrbits = false; 
            specialMeteorite.enteredAtmosphereTime = 0;
            specialMeteorite.burnStartTime = 0; 
            specialMeteorite.orbitalDuration = 3; 
            specialMeteorite.meteoriteBurnDuration = 2;
            specialMeteorite.isFadedOut = false; 
            specialMeteorite.isRemoved = false;
            specialMeteorite.trailIntensity = 1.0;
            specialMeteorite.orbitalSpeed = 0;
            specialMeteorite.orbitalVector = new THREE.Vector3();
            specialMeteorite.initialScale = radius; 
            specialMeteorite.lastParticleTime = 0;

            scene.add(specialMeteorite);
        }

        function createTrailParticle(position, velocity, currentScaleFactor) {
            const particleGeometry = new THREE.SphereGeometry(0.02, 8, 8);
            const particleMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                emissive: 0xadd8e6,
                emissiveIntensity: THREE.MathUtils.randFloat(15.0, 25.0) * currentScaleFactor,
                transparent: true,
                opacity: THREE.MathUtils.randFloat(0.8, 1.0) * currentScaleFactor, 
                blending: THREE.AdditiveBlending
            });
            const particle = new THREE.Mesh(particleGeometry, particleMaterial);
            
            const trailDirection = velocity.clone().negate().normalize();
            const randomOffset = new THREE.Vector3(
                (Math.random() - 0.5) * 0.03, 
                (Math.random() - 0.5) * 0.03,
                (Math.random() - 0.5) * 0.03
            );

            particle.position.copy(position).add(randomOffset);
            particle.velocity = trailDirection.multiplyScalar(THREE.MathUtils.randFloat(0.005, 0.015)); 
            
            particle.lifetime = THREE.MathUtils.randFloat(6.0, 8.0);
            particle.age = 0;
            
            scene.add(particle);
            meteoriteTrailParticles.push(particle);
        }

        function createImpactDebris(impactPosition, impactVelocity) {
            const particleCount = 200;
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.01, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xcccccc, 
                    transparent: true,
                    opacity: 1.0
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(impactPosition);

                const randomDirection = new THREE.Vector3(
                    Math.random() - 0.5,
                    Math.random() - 0.5,
                    Math.random() - 0.5
                ).normalize();
                
                particle.velocity = randomDirection.multiplyScalar(THREE.MathUtils.randFloat(0.01, 0.05));
                particle.lifetime = THREE.MathUtils.randFloat(2.0, 5.0);
                particle.age = 0;
                
                scene.add(particle);
                meteoriteTrailParticles.push(particle);
            }
        }
        
        function cleanupSpecialMeteorite() {
            if (specialMeteorite) {
                scene.remove(specialMeteorite);
                if (specialMeteorite.geometry) {
                    specialMeteorite.geometry.dispose();
                }
                if (specialMeteorite.material) {
                    specialMeteorite.material.dispose();
                }
                specialMeteorite = null;
            }
            for (let i = meteoriteTrailParticles.length - 1; i >= 0; i--) {
                const particle = meteoriteTrailParticles[i];
                scene.remove(particle);
                if (particle.geometry) particle.geometry.dispose();
                if (particle.material) particle.material.dispose();
                meteoriteTrailParticles.splice(i, 1);
            }
        }

        function spawnSpecialMeteorite(targetObject) {
            if (!specialMeteorite) {
                cleanupSpecialMeteorite(); 
                createSpecialMeteorite(targetObject);
            }
        }
        
        function onDoubleClick(event) {
            event.preventDefault();
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects([earth, moon], true);
            
            if (intersects.length > 0) {
                const firstIntersected = intersects[0].object;
                if (firstIntersected === earth) {
                    spawnSpecialMeteorite('earth');
                } else if (firstIntersected === moon) {
                    spawnSpecialMeteorite('moon');
                }
            }
        }

        function onContextMenu(event) {
            if (event) event.preventDefault();
            
            // Logica per cambiare prospettiva
            if (cameraMode === 'orbit') {
                cameraMode = 'moonView';
                controls.enabled = false;
                
                const moonRadius = moon.geometry.parameters.radius;
                const moonViewOffset = new THREE.Vector3(0, moonRadius + 0.1, 0); 
                const moonPosition = moon.position.clone();

                camera.position.copy(moonPosition.add(moonViewOffset));
                
            } else if (cameraMode === 'moonView') {
                cameraMode = 'orbit';
                controls.enabled = true;
                
                camera.position.set(0, 0, 10);
                controls.target.set(0, 0, 0);
            }
        }
        
        function handleLongPress(event) {
            event.preventDefault();

            mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects([moon], true);

            if (intersects.length > 0) {
                onContextMenu();
            }
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            sunLight = new THREE.DirectionalLight(0xffffff, 2);
            sunLight.position.set(10, 0, 0);
            scene.add(sunLight);
            
            scene.add(new THREE.AmbientLight(0x404040, 0.2));

            const textureLoader = new THREE.TextureLoader();
            const earthTexture = textureLoader.load('/local/space/earth_atmos.jpg');
            const cityLightsTexture = textureLoader.load('/local/space/earth_lights.png');
            const moonTexture = textureLoader.load('/local/space/moon_1024.jpg');

            const earthGeometry = new THREE.SphereGeometry(EARTH_RADIUS, 64, 64);
            const earthMaterial = new THREE.MeshStandardMaterial({
                map: earthTexture,
                emissiveMap: cityLightsTexture,
                emissive: new THREE.Color(0xffffff),
                emissiveIntensity: 0.5
            });
            earth = new THREE.Mesh(earthGeometry, earthMaterial);
            
            earthGroup = new THREE.Group();
            earthGroup.add(earth);
            earthGroup.rotation.x = EARTH_AXIAL_TILT;
            
            scene.add(earthGroup);

            const atmosphereGeometry = new THREE.SphereGeometry(ATMOSPHERE_RADIUS, 64, 64);
            const atmosphereMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    "c": { type: "f", value: 0.2 },
                    "p": { type: "f", value: 4 },
                    glowColor: { type: "c", value: new THREE.Color(0x00aaff) },
                    viewVector: { type: "v3", value: camera.position }
                },
                vertexShader: `
                    uniform vec3 viewVector;
                    uniform float c;
                    uniform float p;
                    varying float intensity;
                    void main() {
                        vec3 vNormal = normalize( normalMatrix * normal );
                        vec3 vNormel = normalize( normalMatrix * viewVector );
                        intensity = pow( c - dot(vNormal, vNormel), p );
                        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                    }
                `,
                fragmentShader: `
                    uniform vec3 glowColor;
                    varying float intensity;
                    void main() {
                        vec3 glow = glowColor * intensity;
                        gl_FragColor = vec4( glow, 1.0 );
                    }
                `,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                transparent: true
            });
            const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            earthGroup.add(atmosphere);

            const moonGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const moonMaterial = new THREE.MeshStandardMaterial({
                map: moonTexture
            });
            moon = new THREE.Mesh(moonGeometry, moonMaterial);
            scene.add(moon);
            
            const moonLight = new THREE.SpotLight(0xffcc99, 0.5);
            moonLight.position.set(10, 0, 0);
            moonLight.target = moon;
            scene.add(moonLight);

            satellite = new THREE.Group();
            const bodyGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.3, 16);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9, roughness: 0.3 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            satellite.add(body);
            const panelGeometry = new THREE.BoxGeometry(0.01, 0.2, 0.5);
            const panelMaterial = new THREE.MeshStandardMaterial({
                color: 0x444488,
                emissive: 0x111122,
                metalness: 0.8,
                roughness: 0.2
            });
            const panel1 = new THREE.Mesh(panelGeometry, panelMaterial);
            panel1.position.set(0.15, 0, 0);
            panel1.rotation.z = Math.PI / 2;
            satellite.add(panel1);
            const panel2 = new THREE.Mesh(panelGeometry, panelMaterial);
            panel2.position.set(-0.15, 0, 0);
            panel2.rotation.z = Math.PI / 2;
            satellite.add(panel2);
            scene.add(satellite);
            
            const initialSatelliteAngle = Math.random() * 2 * Math.PI;
            satellite.position.set(
                Math.cos(initialSatelliteAngle) * SATELLITE_ORBIT_RADIUS,
                Math.sin(initialSatelliteAngle) * Math.sin(SATELLITE_INCLINATION) * SATELLITE_ORBIT_RADIUS,
                Math.sin(initialSatelliteAngle) * Math.cos(SATELLITE_INCLINATION) * SATELLITE_ORBIT_RADIUS
            );
            satelliteOrbitAngle = initialSatelliteAngle;
            satellite.scale.setScalar(1);

            moonOrbitAngle = calculateInitialMoonPhase();
            camera.position.z = 10;
            camera.lookAt(0, 0, 0);

            const starCount = 2000;
            const starGeometry = new THREE.BufferGeometry();
            const positions = [];
            const starSpread = 500;
            const MIN_STAR_DISTANCE = 250;

            for (let i = 0; i < starCount; i++) {
                let x, y, z;
                do {
                    x = THREE.MathUtils.randFloat(-starSpread / 2, starSpread / 2);
                    y = THREE.MathUtils.randFloat(-starSpread / 2, starSpread / 2);
                    z = THREE.MathUtils.randFloat(-starSpread / 2, starSpread / 2);
                } while (Math.sqrt(x*x + y*y + z*z) < MIN_STAR_DISTANCE);
                
                positions.push(x, y, z);
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const starMaterial = new THREE.PointsMaterial({
                map: createStarTexture(),
                size: 1.5,
                transparent: true,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.rotateSpeed = 0.5;
            controls.minDistance = 2.5;
            controls.maxDistance = 30;

            window.addEventListener('resize', onWindowResize, false);
            
            for (let i = 0; i < MAX_METEORITES / 2; i++) {
                createMeteorite();
            }

            renderer.domElement.addEventListener('dblclick', onDoubleClick, false);
            renderer.domElement.addEventListener('contextmenu', onContextMenu, false);
            renderer.domElement.addEventListener('touchstart', onTouchStart, false);
            renderer.domElement.addEventListener('touchend', onTouchEnd, false);
            renderer.domElement.addEventListener('touchmove', onTouchEnd, false);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            const atmosphereMesh = earthGroup.children.find(obj => obj.material && obj.material.uniforms && obj.material.uniforms.viewVector);
            if (atmosphereMesh) {
                atmosphereMesh.material.uniforms.viewVector.value.copy(camera.position);
            }
        }

        const clock = new THREE.Clock();
        const PARTICLE_SPAWN_INTERVAL = 0.01; 

        function calibratePeriodically() {
            const newRotation = calculateEarthRotation(userLongitude);
            earthGroup.rotation.y = newRotation;
            console.log("Simulazione ricalibrata.");
        }

        function onTouchStart(event) {
            clearTimeout(touchTimer);
            touchTimer = setTimeout(() => handleLongPress(event), LONG_PRESS_THRESHOLD);
        }

        function onTouchEnd() {
            clearTimeout(touchTimer);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (cameraMode === 'orbit') {
                controls.update();
            }
            
            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();

            updateClock();
            
            const REALISTIC_EARTH_ORBIT_SPEED = (2 * Math.PI) / (365.25 * 24 * 60 * 60); 
            earthOrbitAngle += REALISTIC_EARTH_ORBIT_SPEED * delta;
            sunLight.position.x = Math.cos(earthOrbitAngle) * ORBIT_SEMI_MAJOR_AXIS;
            sunLight.position.z = Math.sin(earthOrbitAngle) * ORBIT_SEMI_MINOR_AXIS;

            earthGroup.rotation.y += REALISTIC_EARTH_ROTATION_SPEED * delta;
            
            const moonDelta = REALISTIC_MOON_SPEED * delta * 1000;
            moonOrbitAngle += moonDelta;
            moon.rotation.y += moonDelta;
            
            moon.position.set(
                Math.cos(moonOrbitAngle) * MOON_ORBIT_RADIUS,
                Math.sin(moonOrbitAngle) * Math.sin(MOON_ORBIT_INCLINATION) * MOON_ORBIT_RADIUS,
                Math.sin(moonOrbitAngle) * Math.cos(MOON_ORBIT_INCLINATION) * MOON_ORBIT_RADIUS
            );

            if (satelliteState === 'orbiting') {
                satelliteOrbitAngle += SATELLITE_ORBIT_SPEED * delta * 1000;
                satellite.position.set(
                    Math.cos(satelliteOrbitAngle) * SATELLITE_ORBIT_RADIUS,
                    Math.sin(satelliteOrbitAngle) * Math.sin(SATELLITE_INCLINATION) * SATELLITE_ORBIT_RADIUS,
                    Math.sin(satelliteOrbitAngle) * Math.cos(SATELLITE_INCLINATION) * SATELLITE_ORBIT_RADIUS
                );
            }

            satellite.rotation.x += 0.01;
            satellite.rotation.y += 0.005;

            const atmosphereMesh = earthGroup.children.find(obj => obj.material && obj.material.uniforms && obj.material.uniforms.viewVector);
            if (atmosphereMesh) {
                atmosphereMesh.material.uniforms.viewVector.value.copy(camera.position);
            }

            if (cameraMode === 'moonView') {
                camera.lookAt(earth.position);
            }
            
            for (let i = meteorites.length - 1; i >= 0; i--) {
                const meteorite = meteorites[i];
                const distanceToEarth = meteorite.position.length();

                if (distanceToEarth <= ATMOSPHERE_RADIUS && !meteorite.isBurning) {
                    meteorite.isBurning = true;
                    meteorite.burnStartTime = elapsedTime;
                    meteorite.material.color.setHex(0xffffff);
                    meteorite.material.emissive.setHex(0xffffff);
                    meteorite.material.emissiveIntensity = 10.0;
                    meteorite.material.transparent = true;
                    meteorite.material.opacity = 1.0;
                }

                if (meteorite.isBurning) {
                    const burnElapsed = elapsedTime - meteorite.burnStartTime;
                    const burnDuration = meteorite.meteoriteBurnDuration;
                    
                    if (burnElapsed < burnDuration) {
                        const scaleReductionFactor = 1.0 - (burnElapsed / burnDuration);
                        meteorite.scale.setScalar(Math.max(0.005, meteorite.initialScale * scaleReductionFactor));
                        meteorite.material.opacity = Math.max(0, scaleReductionFactor);
                        meteorite.material.emissiveIntensity = Math.max(0, 10.0 * scaleReductionFactor);
                        if (elapsedTime - meteorite.lastParticleTime > PARTICLE_SPAWN_INTERVAL) {
                            createTrailParticle(meteorite.position, meteorite.velocity, scaleReductionFactor);
                            meteorite.lastParticleTime = elapsedTime;
                        }
                    } else {
                        scene.remove(meteorite);
                        if (meteorite.geometry) meteorite.geometry.dispose();
                        if (meteorite.material) meteorite.material.dispose();
                        meteorites.splice(i, 1);
                        createMeteorite(); 
                    }
                } else {
                    meteorite.position.add(meteorite.velocity);
                    meteorite.rotation.x += meteorite.velocity.x * 5;
                    meteorite.rotation.y += meteorite.velocity.y * 5;
                    meteorite.rotation.z += meteorite.velocity.z * 5;
                }
            }

            if (specialMeteorite && !specialMeteorite.isRemoved) { 
                specialMeteorite.age = specialMeteorite.age || 0;
                specialMeteorite.age += delta;

                if (specialMeteorite.targetIsMoon) {
                    const distanceToMoon = specialMeteorite.position.distanceTo(moon.position);
                    const moonRadius = moon.geometry.parameters.radius;

                    if (distanceToMoon <= moonRadius + specialMeteorite.initialScale + 0.1) {
                        createImpactDebris(specialMeteorite.position, specialMeteorite.velocity);
                        specialMeteorite.isRemoved = true;
                    } else {
                        specialMeteorite.position.add(specialMeteorite.velocity.clone().multiplyScalar(specialMeteorite.speed));
                    }
                } else {
                    const distanceToEarth = specialMeteorite.position.length();

                    if (distanceToEarth <= ATMOSPHERE_RADIUS && !specialMeteorite.isOrbits) {
                        specialMeteorite.isOrbits = true;
                        specialMeteorite.burnStartTime = specialMeteorite.age; 
                        specialMeteorite.material.emissive.setHex(0xffffff);
                        specialMeteorite.material.color.setHex(0xffffff);
                        specialMeteorite.material.emissiveIntensity = 10.0;
                        specialMeteorite.velocity.normalize();
                        let initialOrbitalDirection = new THREE.Vector3().crossVectors(specialMeteorite.velocity, new THREE.Vector3(0, 1, 0)).normalize();
                        const randomRotationAxis = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
                        const randomRotationAngle = Math.random() * Math.PI * 2;
                        initialOrbitalDirection.applyAxisAngle(randomRotationAxis, randomRotationAngle);
                        specialMeteorite.orbitalSpeed = THREE.MathUtils.randFloat(0.01, 0.03); 
                        specialMeteorite.orbitalVector.copy(initialOrbitalDirection);
                    }

                    if (specialMeteorite.isOrbits) {
                        specialMeteorite.position.add(specialMeteorite.orbitalVector.clone().multiplyScalar(specialMeteorite.orbitalSpeed));
                        const targetRadius = ATMOSPHERE_RADIUS;
                        specialMeteorite.position.normalize().multiplyScalar(targetRadius);
                        specialMeteorite.velocity.copy(specialMeteorite.orbitalVector);
                        const burnElapsed = specialMeteorite.age - specialMeteorite.burnStartTime;
                        
                        if (burnElapsed < specialMeteorite.meteoriteBurnDuration) {
                            const scaleReductionFactor = 1.0 - (burnElapsed / specialMeteorite.meteoriteBurnDuration);
                            specialMeteorite.scale.setScalar(Math.max(0.005, specialMeteorite.initialScale * scaleReductionFactor));
                            specialMeteorite.material.opacity = Math.max(0, scaleReductionFactor);
                            specialMeteorite.material.emissiveIntensity = Math.max(0, 10.0 * scaleReductionFactor);
                            if (specialMeteorite.age - specialMeteorite.lastParticleTime > PARTICLE_SPAWN_INTERVAL) {
                                createTrailParticle(specialMeteorite.position, specialMeteorite.velocity, scaleReductionFactor);
                                specialMeteorite.lastParticleTime = specialMeteorite.age;
                            }
                        } else {
                            specialMeteorite.isRemoved = true;
                        }
                    } else {
                        specialMeteorite.position.add(specialMeteorite.velocity.clone().multiplyScalar(specialMeteorite.speed));
                        if (specialMeteorite.position.length() > 40 && specialMeteorite.age > 5) {
                            specialMeteorite.isRemoved = true;
                        }
                    }
                }
            }
            
            if (specialMeteorite && specialMeteorite.isRemoved) {
                if (meteoriteTrailParticles.length === 0) {
                    cleanupSpecialMeteorite();
                } else {
                    if (specialMeteorite.material) {
                        specialMeteorite.material.opacity = 0;
                        specialMeteorite.material.emissiveIntensity = 0;
                    }
                }
            }

            for (let i = meteoriteTrailParticles.length - 1; i >= 0; i--) {
                const particle = meteoriteTrailParticles[i];
                particle.age += delta;
                
                particle.position.add(particle.velocity.clone().multiplyScalar(delta));
                
                const fadeFactor = 1 - (particle.age / particle.lifetime);
                particle.material.opacity = Math.max(0, fadeFactor);
                particle.material.emissiveIntensity = THREE.MathUtils.clamp(particle.material.emissiveIntensity, 0, particle.material.emissiveIntensity) * fadeFactor;
                particle.scale.setScalar(Math.max(0.005, fadeFactor)); 

                if (particle.age >= particle.lifetime || particle.material.opacity <= 0) {
                    scene.remove(particle);
                    if (particle.geometry) particle.geometry.dispose();
                    if (particle.material) particle.material.dispose();
                    meteoriteTrailParticles.splice(i, 1);
                }
            }
            
            renderer.render(scene, camera);
        }

        function startSimulation(longitude) {
            userLongitude = longitude;
            initialEarthRotation = calculateEarthRotation(userLongitude);
            init();
            earthGroup.rotation.y = initialEarthRotation - THREE.MathUtils.degToRad(180);
            animate();
            
            setInterval(calibratePeriodically, 3600000); 
        }

        function getLocationAndInit() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    position => {
                        const { longitude } = position.coords;
                        startSimulation(longitude);
                    },
                    error => {
                        console.error('Errore di geolocalizzazione:', error);
                        startSimulation(0);
                    }
                );
            } else {
                startSimulation(0);
            }
        }

        window.onload = function() {
            getLocationAndInit();
        };
    </script>
</body>
</html>